---
title: "Main Code"
author: "Margaret Perry"
date: "November 18, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
library(readr)
library(igraph)
library(sna)
library(sand)
library(blockmodels)
library(sna)
```

##import data 

```{r}
library(sna)
library(network)
data1<-read.csv("CSV/60_PERIOD1_ATTT.csv")
data2<-read.csv("CSV/60_PERIOD2_ATT.csv")
data3<-read.csv("CSV/60_PERIOD3_ATT.csv")
edges1<-read.csv("CSV/60_PERIOD1_NET.csv", header=TRUE)
edges2<-read.csv("CSV/60_PERIOD2_NET.csv", header=TRUE)
edges3<-read.csv("CSV/60_PERIOD3_NET.csv", header=TRUE)
```

## creating adjency matrix for the three dataset 

```{r}
# change character form into numarical form:
adj.matrix.1<-as.matrix(edges1)[,-1] # make sure as many columns as rows
class(adj.matrix.1)<-"numeric"

adj.matrix.2<-as.matrix(edges2)[,-1] # make sure as many columns as rows
class(adj.matrix.2)<-"numeric"

adj.matrix.3<-as.matrix(edges3)[,-1] # make sure as many columns as rows
class(adj.matrix.3)<-"numeric"

```

## examing missing data 

Here we can compare the number of missing data with the number of total data
```{r}
nrow(data1[data1$Marital.Status!=99999,]) # see valid data with marrital status not missing for data 1
nrow(data2[data2$Marital.Status!=99999,]) # same thing for data 2 
nrow(data3[data3$Marital.Status!=99999,]) # for data 3

nrow(data1)
nrow(data2)
nrow(data3)
```

##Visualizing 

```{r}
gplot(adj.matrix.1,main="Period 1", vertex.col="Blue")
gplot(adj.matrix.2,main="Period 2", vertex.col="Purple")
gplot(adj.matrix.3,main="Period 3", vertex.col = "Orange")

```


## Blockmodel 
```{r}
gplot(adj.matrix.1)

my_model<-BM_bernoulli(
"SBM",
adj.matrix.n,
verbosity=6,
autosave='',
plotting=character(0),
exploration_factor=1.5,
explore_min=4,
explore_max=Inf,
ncores=detectCores())

#my_model <- BM_bernoulli_multiplex("SBM",list(adj.matrix), plotting='', explore_min=2, explore_max=2, ncores=2, verbosity=0)
my_model$estimate()

which.max(my_model$ICL)

num.clusters<-3 #use number from which.max command above
my_model$memberships[[num.clusters]]$Z #gives probability of being in each group
my_model$memberships[[num.clusters]]$plot() #plots the group memberships



```

# Block Model Version 2

We are going to simulate our own network 
```{r}
## generation of one SBM network
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1) #??
P<-matrix(runif(Q*Q),Q,Q) # matrix for classes 
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix; t is transpose of matrix Z

```
Let's see what we get back when we run a SBM on this simulated network
```{r}
my_model <- BM_bernoulli("SBM", M)
my_model$estimate()
which.max(my_model$ICL)
num.clusters<-3
my_model$memberships[[num.clusters]]$Z #gives probability of being in each group
my_model$memberships[[num.clusters]]$plot() #plots the group memberships
```

# latent model 


```{r}
library(eigenmodel)
lazega.leig.fit1 <- eigenmodel_mcmc(adj.matrix, R=2, S=11000,
burn=10000)
```




